# 排序算法总结


## 1.时间复杂度为O（n2）、

### 1.1 冒泡排序

**对应算法题练习**

剑指 Offer 45.把数组排成最小的数
```python
class Solution:
    def minNumber(self, nums: List[int]) -> str:
        ## 本质上是冒泡排序，如果ab组成的字符串大于ba组成的字符串，则交换
        swap = True
        for i in range(len(nums)):
            if not swap:
                break
            swap = False
            for j in range(1,len(nums)-i):
           
                if int(str(nums[j-1])+str(nums[j])) > int(str(nums[j])+str(nums[j-1])):
                    nums[j],nums[j-1] = nums[j-1],nums[j]
                    # print(nums[j-1],nums[j])
                    swap = True
        s = ''
        for i in nums:
            s = s + str(i)
        return s
        ## 时间复杂度O（N2） 空间复杂度O（1）
```


- 2.移动零

###1.2 选择排序

**数组中的第K个最大元素**


###1.3 插入排序

|比较项|冒泡排序|选择排序|插入排序|
|-|-|-|-|
|时间复杂度|O（N2）|O（N2）|O（N2）|
|空间复杂度|O（1）|O（1）|O（1）|
|是否稳定|稳定|不稳定|不稳定|

#### 1.4 总结
**冒泡排序**

冒泡排序有两种优化方式：

- 记录当前轮次是否发生过交换，没有发生过交换表示数组已经有序；
- 记录上次发生交换的位置，下一轮排序时只比较到此位置。

**选择排序**

选择排序可以演变为二元选择排序：

- 二元选择排序：一次遍历选出两个值——最大值和最小值；
- 二元选择排序剪枝优化：当某一轮遍历出现最大值和最小值相等，表示数组中剩余元素已经全部相等。

**插入排序**

插入排序有两种写法：

- 交换法：新数字通过不断交换找到自己合适的位置；
- 移动法：旧数字不断向后移动，直到新数字找到合适的位置。

**相同点**
时间复杂度都是 O(n^2)
空间复杂度都是 O(1)

都需要采用两重循环。

**不同点**

- 选择排序是不稳定的，冒泡排序、插入排序是稳定的；
- 在这三个排序算法中，选择排序交换的次数是最少的；
- 在数组几乎有序的情况下，插入排序的时间复杂度接近线性级别。



## 2.时间复杂度为O（nlogn）

###2.1 希尔排序

###2.2 堆排序

###2.3快速排序

###2.4 归并排序


## 3.时间复杂度O（n）

### 3.1 计数排序
### 3.2 基数排序